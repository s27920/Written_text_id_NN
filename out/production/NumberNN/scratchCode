//    private void build(){
//        Perceptron perceptron = new Perceptron(new byte[784]);
//        Perceptron.createSuccessors(perceptron, structure, 1);
//        System.out.println(Perceptron.objectCounter);
//    }


//    public static void createSuccessors(Perceptron builder, int[] structure, int index){
//        if(index < structure.length){
//            for (int i = 1; i < structure[index]; i++) {
//                builder.successor[i] = new Perceptron(new byte[structure[i-1]]);
//            }
//            createSuccessors(builder.successor[0], structure, index+1);
//        }
//


//public static void setSucConnection(Perceptron curr, Perceptron suc){
//    curr.successor[curr.sucIndex] = suc;
//    suc.predecessor[suc.predIndex] = curr;
//    curr.sucIndex++;
//    suc.predIndex++;
//}

//public class Image<T> {
//    private final T[] pixelVector;
//    private final T label;
//
//    public Image(T[] pixelVector, T label) {
//        this.pixelVector = pixelVector;
//        this.label = label;
//    }
//
//    public T[] getPixels() {
//        return pixelVector;
//    }
//
//    public T getNumVal() {
//        return label;
//    }
//}

float[] getESquared(float[] activations){
        int length = activations.length;
        float cost[] = new float[length];
        float correct;
        for (int i = 0; i < length; i++) {
            correct = 0.0f;
            if (i == currentLabel){
                correct = 1.0f;
            }
            cost[i] = (float) ((Math.pow((activations[i] - correct),2))/2);
        }
        return cost;
    }


    User
    public void train(float[] activations){
            float[] correct = new float[10];
            correct[currentLabel] = 1.0f;
            Perceptron[] layer = terminalLayer;
            Perceptron[] prevLayer;
            Perceptron[] sucLayer;
            float[] prevErrorGradients = null;
            while ((prevLayer = layer[0].predecessor)!=null){
                int prevLayerSize = prevLayer.length;
                int currLayerSize = layer.length;
                float[] tmpErrorGradients = new float[currLayerSize];
                for (int i = 0; i < currLayerSize; i++) {
                    float activation = activations[i];
                    float errorGradient;
                    if (layer == terminalLayer) {
                        errorGradient = correct[i] - activation;
                        tmpErrorGradients[i] = errorGradient;
                    } else {
                        sucLayer = layer[i].successor;
                        float[] weights = sucLayer[i].getWeights();
                        float weighedSum = 0.0f;
                        for (int j = 0; j < sucLayer.length; j++) {
                            weighedSum+= prevErrorGradients[j]
                                    * weights[j];
                        }
                        errorGradient = weighedSum;
                    }
                    for (int j = 0; j < prevLayerSize; j++) {
                        prevLayer[j].getWeights()[i] += prevLayer[j].getOutput() * errorGradient * (1 - activation*activation);
                    }
                    tmpErrorGradients[i] = errorGradient;
                }
                prevErrorGradients = tmpErrorGradients;
                activations = new float[prevLayerSize];
                for (int i = 0; i < prevLayerSize; i++) {
                    activations[i]=prevLayer[i].getOutput();
                }
                layer=prevLayer;
            }
        }



int currLayerSize = structure[index];
        Perceptron[] currLayer = new Perceptron[currLayerSize];
        int previousLayerSize = previousLayer.length;
        for (int i = 0; i < currLayerSize; i++) {
            Perceptron perceptron = new Perceptron(previousLayerSize);
            perceptron.setPredecessors(new Perceptron[previousLayerSize]);
            perceptron.setSuccessors(new Perceptron[structure[index+1]]);
            for (Perceptron predecessor : previousLayer) {
                Perceptron.setPredConnection(predecessor, perceptron);
            }
            currLayer[i] = perceptron;
        }
        if(index < structure.length-2){
            return hiddenLayers(structure, currLayer, index+1);
        }else {
            return terminalLayer(structure, currLayer, index+1);
        }

        private Perceptron[] terminalLayer(int[] structure, Perceptron[] previousLayer, int index){
                int currLayerSize = structure[index];
                Perceptron[] finalLayer = new Perceptron[currLayerSize];
                int previousLayerSize = previousLayer.length;
                for (int i = 0; i < currLayerSize; i++) {
                    Perceptron perceptron = new Perceptron(previousLayerSize);
                    perceptron.setPredecessors(new Perceptron[previousLayerSize]);
                    for (Perceptron predecessor : previousLayer) {
                        Perceptron.setPredConnection(predecessor, perceptron);
                    }
                    finalLayer[i] = perceptron;
                }
                return finalLayer;
            }